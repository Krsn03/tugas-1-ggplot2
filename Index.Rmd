---
title: "Tugas 1 Data Visual"
author: "Kresna Ardy Bayuaji-RPL-A320240009-Institut Teknologi Statistika dan Bisnis Muhammadiyah"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: flatly
    higlight: zenburn
    toc: true
    toc_float:
      collapsed: true
    df_print: paged
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style>
body{
text-align: justify}
</style>
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(ggplot2)
```

# Langkah Pertama

## 1.1 Pendahuluan

Pada bab ini dijelaskan bahwa tujuannya adalah membantu Anda memahami
cara membuat visualisasi data yang informatif menggunakan ggplot2 dengan
cepat dan efisien. Anda akan dikenalkan pada dasar penggunaan fungsi
`ggplot()` serta beberapa contoh “resep” praktis untuk menghasilkan
berbagai jenis grafik yang umum digunakan. Fungsi `ggplot()`
memungkinkan kita membuat visualisasi yang kompleks hanya dengan
beberapa baris kode, karena dibangun berdasarkan konsep mendasar yang
disebut *tata bahasa grafik*.

Fokus pembahasan di bagian ini adalah pada praktik langsung, bukan
teori. Pembahasan mendalam mengenai konsep dan fleksibilitas *tata
bahasa grafik* akan dijelaskan lebih lanjut pada bab berikutnya.

Dalam bab ini, Anda akan mempelajari beberapa hal penting, antara lain:

1.  Penggunaan dataset mpg yang tersedia di paket ggplot2,
2.  Tiga elemen utama dalam pembuatan plot: data, estetika, dan
    geometri,
3.  Cara menambahkan variabel baru ke dalam plot melalui estetika,
4.  Teknik menampilkan variabel kategoris menggunakan faceting atau
    kelipatan kecil,
5.  Jenis-jenis geom yang dapat digunakan untuk membentuk berbagai tipe
    grafik,
6.  Cara mengubah tampilan sumbu (axis) pada plot, serta
7.  Berbagai hal lain yang dapat dilakukan terhadap objek plot, seperti
    menyimpan hasil grafik ke dalam file.

## 1.2 Data Penghematan Bahan Bakar

Dalam bab ini, kami akan menggunakan satu set data yang dibundel dengan
ggplot2: mpg. Data ini berisi sebuah informasi tentang konsumsi bahan
bakar model mobil populer pada tahun 1999 dan 2008, yang dikumpulkan
oleh Badan Perlindungan Lingkungan AS, <http://fueleconomy.gov> . Anda
dapat mengakses data tersebut dengan memuat ggplot2:

```{r}
#> # A tibble: 234 × 11
#>   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class 
#>   <chr>        <chr> <dbl> <int> <int> <chr>      <chr> <int> <int> <chr> <chr> 
#> 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…
#> 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…
#> 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…
#> 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…
#> 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa…
#> 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa…
#> # ℹ 228 more rows
```

Variabel-variabelnya sebagian besar dapat dijelaskan sendiri:

-   `cty`(city) dan `hwy`(highway) rekor mil per galon (mpg) untuk
    berkendara di daerah kota dan jalan raya.

-   `displ`(displacement) adalah kapasitas mesin dalam liter.

-   `drv`(drivetrain) adalah tipe penggerak: roda depan (f), roda
    belakang (r) atau empat roda (4).

-   `model` adalah model mobil. Ada 38 model yang dipilih karena
    memiliki edisi baru setiap tahun antara tahun 1999 dan 2008.

-   `class` adalah variabel kategoris yang menggambarkan “tipe” mobil:
    dua penumpang, SUV, kompak, dll.

## 1.3 Komponen Utama

Setiap plot ggplot2 memiliki tiga komponen utama:

1.  **data**,
2.  Seperangkat **pemetaan estetika** antara variabel dalam data dan
    properti visual, dan
3.  Setidaknya satu lapisan yang menjelaskan cara merender setiap
    observasi. Lapisan biasanya dibuat dengan fungsi **geom**.

Berikut ini contoh sederhananya:

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()
```

Kode di atas menghasilkan grafik sebar (scatter plot) dengan komponen
sebagai berikut:

1.  Data: menggunakan dataset `mpg`.
2.  Pemetaan estetika: variabel `displ` (ukuran mesin) diletakkan ke
    sumbu x, sedangkan `hwy` (efisiensi bahan bakar di jalan raya)
    diletakkan ke sumbu y.
3.  Lapisan: ditampilkan dalam bentuk titik (*points*).

Struktur pemanggilan fungsi ini memiliki pola yang penting untuk
dipahami: data dan pemetaan estetika ditentukan di dalam fungsi
`ggplot()`, kemudian lapisan ditambahkan dengan tanda `+`. Pola ini akan
sering digunakan, dan seiring dengan bertambahnya kompleksitas grafik
yang dibuat, Anda akan menambahkan lebih banyak komponen menggunakan
pendekatan yang sama.

Karena hampir semua grafik menggunakan variabel x dan y, Anda tidak
selalu perlu menulisnya secara terus menerus. Dua argumen pertama di
dalam aes() secara otomatis dianggap sebagai sumbu x dan y. Oleh karena
itu, contoh berikut menghasilkan grafik yang sama dengan kode
sebelumnya:

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point()
```

Gaya penulisan seperti ini akan digunakan secara konsisten di seluruh
bagian pembahasan. Disarankan untuk menulis setiap bagian perintah pada
baris terpisah agar lebih mudah dibaca dan dipahami. Namun, dalam
beberapa contoh sederhana, semua perintah mungkin digabung dalam satu
baris untuk memperjelas perbandingan antar plot.

Hasil grafik menunjukkan adanya hubungan yang cukup jelas: semakin besar
kapasitas mesin kendaraan, semakin tinggi pula konsumsi bahan bakarnya.
Meskipun demikian, terdapat beberapa pengecualian menarik misalnya,
beberapa mobil dengan mesin besar justru memiliki efisiensi bahan bakar
yang lebih baik dari rata-rata. Hal ini menimbulkan pertanyaan menarik
mengenai jenis mobil apa yang memiliki karakteristik seperti itu.

## 1.4 Warna, Ukuran, Bentuk, dan Atribut Estetika Lainnya

Kita bisa menambahkan variabel lain ke dalam grafik dengan menggunakan
elemen visual tambahan seperti warna, bentuk, atau ukuran titik. Caranya
sama seperti saat kita memetakan variabel ke sumbu `x` dan `y`, yaitu
dengan menambahkannya ke dalam fungsi `aes()`.

-   `aes(displ, hwy, colour = class)`(menambahkan warna berdasarkan
    jenis mobil)
-   `aes(displ, hwy, shape = drv)` (mengubah bentuk titik sesuai tipe
    penggerak (f,r,4))
-   `aes(displ, hwy, size = cyl)`(mengatur ukuran titik berdasarkan
    jumlah silinder)

Fungsi ggplot2 akan otomatis mengubah data yang berupa angka atau huruf
menjadi tampilan visual. Misalnya, variabel `class` bisa diterjemahkan
menjadi warna yang berbeda, seperti merah, biru, atau hijau. Proses
penerjemahan ini diatur oleh yang disebut **skala (scale)**\*.

Setiap elemen estetika (warna, bentuk, ukuran, dan lainnya) memiliki
satu skala sendiri. Skala inilah yang juga membuat ***sumbu, legenda,
dan panduan*** pada grafik agar kita bisa membaca data dengan mudah dan
memahami hubungan antar variabel.

Untuk memahami lebih dalam tentang perbedaan antar variabel pada diagram
sebar sebelumnya, kita bisa menambahkan warna berdasarkan variabel
`class` seperti contoh berikut:

```{r}
ggplot(mpg, aes(displ, hwy, colour = class)) + 
  geom_point()
```

Kode ini akan memberi ***warna berbeda pada setiap titik*** sesuai
dengan kelas mobilnya. Bagian ***legenda*** di sisi grafik membantu kita
mengetahui warna mana yang mewakili tiap jenis mobil. Dari hasil plot,
terlihat bahwa ***mobil dua tempat duduk (2-seater)*** memiliki
efisiensi bahan bakar paling tinggi dibandingkan ukuran mesinnya karena
mobil ini umumnya ***bermesin besar namun berbobot ringan***.

Jika kita ingin memberikan warna tetap tanpa mengaitkannya pada variabel
data, maka penulisannya dilakukan di luar fungsi `aes()`. Perhatikan
perbedaan dua contoh berikut:

```{r}
ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = "blue"))
ggplot(mpg, aes(displ, hwy)) + geom_point(colour = "blue")
```

Pada contoh pertama, `"blue"` dianggap sebagai ***nilai variabel
baru***, sehingga warnanya akan ***diskalakan*** (biasanya berubah
menjadi warna lain, seperti merah muda) dan ***legenda akan muncul***.
Sedangkan pada contoh kedua, `"blue"` benar-benar diartikan sebagai
***warna biru murni*** untuk semua titik tanpa legenda tambahan. Untuk
mengetahui daftar warna dan atribut lain yang bisa digunakan, Anda dapat
melihat dokumentasi `vignette("ggplot2-specs")`.

Beberapa atribut estetika lebih cocok untuk tipe data tertentu.Misalnya:

-   Warna dan bentuk lebih sesuai untuk variabel kategori,
-   Ukuran titik lebih cocok untuk variabel numerik atau kontinu.

Selain itu, ***jumlah data*** juga berpengaruh jika titik terlalu
banyak, perbedaan antar kelompok bisa sulit terlihat. Salah satu solusi
agar data tetap mudah dibaca adalah dengan menggunakan faceting, yaitu
membagi plot ke dalam beberapa tampilan kecil berdasarkan kategori
tertentu.

Terakhir, perlu diingat bahwa ***terlalu banyak elemen estetika dalam
satu plot justru bisa membingungkan***. Sulit bagi mata manusia untuk
membedakan hubungan antara warna, bentuk, dan ukuran sekaligus. Daripada
membuat satu grafik yang rumit, lebih baik ***membuat beberapa plot
sederhana*** yang saling melengkapi dan menceritakan cerita data secara
bertahap dari hal yang belum diketahui hingga menjadi lebih jelas dan
mudah dipahami.

## 1.5 Pemotongan Sisi

ada cara lain atau teknik lain untuk menampilkan ***variabel kategori
tambahan*** pada plot adalah dengan menggunakan ***faceting***. Teknik
ini membuat beberapa grafik kecil (sub-plot) dengan cara ***membagi data
ke dalam kelompok-kelompok tertentu***, lalu menampilkan grafik yang
sama untuk setiap kelompok tersebut.

Ada dua jenis faceting di ggplot2, yaitu grid dan wrapped.Namun, jenis
wrapped biasanya lebih sering digunakan karena lebih fleksibel dan mudah
diatur tampilannya.

Untuk menambahkan faceting ke dalam grafik, cukup tambahkan fungsi
`facet_wrap()` dan tuliskan nama variabel yang ingin digunakan setelah
tanda `~`. Contohnya seperti berikut:

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  facet_wrap(~class)
```

## 1.6 Plot Geom

Kamu mungkin sudah bisa menebak, bahwa jika kita mengganti fungsi
`geom_point()` dengan fungsi geom lain, maka ***bentuk grafik yang
dihasilkan juga akan berubah***.Di bagian ini, kamu akan mengenal
beberapa geom penting lainnya yang disediakan oleh ggplot2. Daftar
berikut memang belum mencakup semuanya, tetapi sudah mencakup ***jenis
grafik yang paling umum digunakan*** dalam analisis data.

-   `geom_smooth()` → membuat ***garis tren (trend line)*** dan
    menampilkan rentang kesalahan standar, cocok untuk melihat pola umum
    dalam data.
-   `geom_boxplot()` → menampilkan ***diagram kotak dan garis
    (boxplot)*** untuk menggambarkan penyebaran data atau perbandingan
    antar kelompok.
-   `geom_histogram()` dan `geom_freqpoly()` → digunakan untuk
    ***melihat distribusi data numerik*** (variabel kontinu), misalnya
    untuk mengetahui seberapa sering nilai tertentu muncul.
-   `geom_bar()` → digunakan untuk ***menunjukkan distribusi variabel
    kategori***, seperti jumlah mobil per jenis bahan bakar.
-   `geom_path()` dan `geom_line()`→ menggambar ***garis penghubung
    antar titik data***.
    -   `geom_line()` biasanya digunakan untuk ***data berurutan***,
        misalnya perubahan nilai dari waktu ke waktu.
    -   Sedangkan `geom_path()` bisa menggambar ***jalur yang lebih
        bebas***, tidak harus dari kiri ke kanan.

Dengan mengganti jenis geom yang digunakan, kamu bisa ***membuat
berbagai bentuk visualisasi berbeda dari data yang sama***, tergantung
pada informasi apa yang ingin kamu tampilkan.

### 1.6.1 Menambahkan Penghalus ke Plot

Ketika sebuah diagram sebar memiliki banyak ***noise*** (titik data yang
tersebar acak), terkadang ***pola utama atau tren data sulit terlihat
dengan jelas***. Untuk membantu memperjelas tren tersebut, kita bisa
menambahkan ***garis halus*** menggunakan fungsi `geom_smooth()` seperti
contoh berikut:

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  geom_smooth()
#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'
```

Kode di atas menambahkan ***garis lengkung halus (smooth curve)*** ke
dalam diagram sebar.Garis ini memperlihatkan ***arah atau tren umum***
dari data, sedangkan ***area abu-abu*** di sekitar garis menunjukkan
***tingkat ketidakpastian*** atau ***interval keyakinan***.

Jika kamu tidak ingin menampilkan area abu-abu tersebut, kamu bisa
menonaktifkannya dengan menambahkan argumen se = FALSE, seperti berikut:
`geom_smooth(se = FALSE`)

Fungsi `geom_smooth()` memiliki argumen penting bernama `method`, yang
digunakan untuk menentukan jenis model statistik yang akan digunakan
untuk membuat garis halusnya. Secara default, untuk jumlah data yang
tidak terlalu besar, ggplot2 menggunakan metode ***"loess"***, yaitu
regresi lokal yang menghasilkan garis mengikuti pola data di sekitar
setiap titik.

Selain itu, ada juga parameter tambahan bernama `span` yang mengatur
seberapa halus garis tersebut:

\- Nilai 0 → garis menjadi lebih bergelombang (sensitif terhadap
perubahan kecil pada data).

\- Nilai 1 → garis menjadi lebih halus dan tidak terlalu mengikuti
fluktuasi kecil.

Dengan menambahkan `geom_smooth()`, kamu dapat melihat tren atau
hubungan antar variabel dengan lebih jelas, bahkan ketika datanya tampak
acak atau berisik.

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  geom_smooth(span = 0.2)
#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'

ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  geom_smooth(span = 1)
#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'
```

Metode ***loess*** memang bagus untuk membuat garis halus pada data yang
tidak terlalu besar, tetapi ***tidak cocok digunakan untuk dataset
besar***.Hal ini karena algoritma loess membutuhkan memori yang cukup
besar (sekitar ***O(n²)***), sehingga ketika jumlah data melebihi
***1.000 baris***, performanya akan menurun.Untuk mengatasi hal
tersebut, ggplot2 secara otomatis akan menggunakan ***metode penghalusan
alternatif*** yang lebih efisien.

Beberapa metode yang bisa digunakan antara lain: - `method = "gam"`
Metode ini menggunakan ***Generalized Additive Model (GAM)*** yang
disediakan oleh paket mgcv.Model ini lebih cocok untuk data besar dan
bisa menangani pola non-linear dengan baik.Sebelum digunakan, kamu perlu
memuat paket mgcv terlebih dahulu dengan `library(mgcv).`Contohnya:

```{r}
library(mgcv)
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  geom_smooth(method = "gam", formula = y ~ s(x))
```

-   `method = "lm"` Jika kamu ingin membuat ***garis linear
    sederhana***, gunakan metode ini.`lm`adalah singkatan dari ***Linear
    Model***, dan akan menampilkan garis lurus terbaik yang mewakili
    hubungan antara dua variabel. Contohnya:

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  geom_smooth(method = "lm")
#> `geom_smooth()` using formula = 'y ~ x'
```

-   `method = "rlm"` Metode ini bekerja mirip dengan `lm()`, namun lebih
    ***tahan terhadap data ekstrem (outlier)***.`rlm` merupakan bagian
    dari paket ***MASS***, jadi jangan lupa untuk memuatnya terlebih
    dahulu dengan `library(MASS)` sebelum digunakan. Metode ini cocok
    jika data kamu memiliki beberapa nilai ekstrem yang bisa mengganggu
    hasil garis regresi biasa.

### 1.6.2 Boxplot dan Titik-Titik Yang Bergetar

Jika sebuah kumpulan data memiliki satu ***variabel kategorik*** dan
satu atau lebih ***variabel kontinu***, kita biasanya ingin mengetahui
bagaimana nilai variabel kontinu tersebut berubah pada setiap
kategori.Sebagai contoh, kita bisa melihat bagaimana efisiensi bahan
bakar (hwy) berbeda berdasarkan jenis drivetrain (drv) mobil. Kita bisa
mulai dengan diagram sebar berikut:

```{r}
ggplot(mpg, aes(drv, hwy)) + 
  geom_point()
```

Namun, karena nilai `drv` dan `hwy` memiliki jumlah kategori dan rentang
yang terbatas, akan terjadi overplotting banyak titik saling menumpuk di
posisi yang sama, sehingga distribusi data sulit terlihat. Untuk
mengatasi hal ini, ada tiga teknik yang dapat digunakan:

1.  ***Jittering `(geom_jitter()`)*** Menambahkan sedikit noise acak
    pada posisi titik agar tidak saling menimpa.
2.  ***Boxplot `(geom_boxplot()`)*** Menampilkan ringkasan distribusi
    menggunakan statistik seperti median, kuartil, dan pencilan.
3.  ***Violin plot `(geom_violin()`)*** Menunjukkan kepadatan distribusi
    secara visual, sehingga area dengan banyak data terlihat lebih
    jelas.

Contohnya:

```{r}
ggplot(mpg, aes(drv, hwy)) + geom_jitter()
ggplot(mpg, aes(drv, hwy)) + geom_boxplot()
ggplot(mpg, aes(drv, hwy)) + geom_violin()
```

Masing-masing metode memiliki kelebihan dan kekurangan:

\- ***Boxplot*** hanya menampilkan ringkasan data dengan lima angka
utama, tetapi mudah dibaca.

\- ***Jittered plot*** memperlihatkan setiap titik data, namun paling
cocok untuk dataset kecil.

\- ***Violin plot*** memberikan tampilan paling informatif karena
memperlihatkan bentuk distribusi, meskipun hasilnya bergantung pada
estimasi kepadatan yang bisa jadi sulit ditafsirkan.

Selain itu,

-   `geom_jitter()` mendukung pengaturan estetika seperti `size`,
    `colour`, dan `shape`, sama seperti `geom_point()`.

<!-- -->

-   Pada `geom_boxplot()` dan `geom_violin()`, kamu juga bisa mengatur
    warna garis luar (`colour`) dan warna isi (`fill`) untuk memperjelas
    tampilan grafik.

### 1.6.3 Histogram dan Poligon Frekuensi

Histogram dan poligon frekuensi digunakan untuk menampilkan distribusi
dari satu variabel numerik. Kedua jenis grafik ini memberikan gambaran
yang lebih rinci tentang bentuk distribusi suatu kelompok dibandingkan
dengan boxplot, meskipun membutuhkan ruang visual yang lebih besar.

```{r}
ggplot(mpg, aes(hwy)) + geom_histogram()
#> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.
ggplot(mpg, aes(hwy)) + geom_freqpoly()
#> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.
```

Baik histogram maupun poligon frekuensi bekerja dengan prinsip yang sama
***data dibagi ke dalam beberapa kelompok (bin)***, lalu dihitung jumlah
observasi pada setiap kelompok tersebut. Perbedaannya hanya pada
tampilan: histogram menggunakan ***batang***, sementara poligon
frekuensi menggunakan ***garis penghubung antar titik frekuensi***.

Ukuran lebar setiap bin dapat diatur melalui argumen `binwidth`. Jika
Anda ingin menggunakan bin dengan ukuran berbeda, Anda bisa memanfaatkan
argumen `breaks`.Menentukan lebar bin yang tepat sangat penting, karena
pengaturan bawaan (biasanya 30 bin) belum tentu sesuai untuk setiap
dataset. Disarankan untuk mencoba beberapa nilai binwidth agar dapat
memperoleh gambaran distribusi yang lebih akurat.

```{r}
ggplot(mpg, aes(hwy)) + 
  geom_freqpoly(binwidth = 2.5)
ggplot(mpg, aes(hwy)) + 
  geom_freqpoly(binwidth = 1)
```

Sebagai alternatif dari poligon frekuensi, Anda juga dapat menggunakan
plot kepadatan (`geom_density()`). Namun, perlu kehati-hatian dalam
menginterpretasikan hasilnya. Plot kepadatan lebih kompleks karena
menggunakan estimasi fungsi kepadatan probabilitas, dengan asumsi bahwa
data bersifat kontinu, tak terbatas, dan halus sesuatu yang tidak selalu
berlaku untuk semua jenis data.

Untuk membandingkan distribusi beberapa kelompok kategori, Anda bisa
memetakan variabel kategorik ke dalam: - warna (`colour`) untuk
`geom_freqpoly()`, atau - isian (`fill`) untuk `geom_histogram()`.

Perbandingan menggunakan poligon frekuensi seringkali lebih mudah karena
perbedaan antar distribusi lebih jelas terlihat.Selain itu, Anda juga
bisa menggunakan faceting untuk menampilkan setiap kelompok dalam panel
terpisah cara ini memudahkan visualisasi distribusi masing-masing
kelompok meskipun sedikit lebih sulit untuk membandingkannya langsung.

```{r}
ggplot(mpg, aes(displ, colour = drv)) + 
  geom_freqpoly(binwidth = 0.5)
ggplot(mpg, aes(displ, fill = drv)) + 
  geom_histogram(binwidth = 0.5) + 
  facet_wrap(~drv, ncol = 1)
```

### 1.6.4 Grafik Batang

***Diagram batang*** adalah ***versi diskrit dari histogram***, dan
dapat dibuat dengan sangat mudah menggunakan fungsi `geom_bar()`:

```{r}
ggplot(mpg, aes(manufacturer)) + 
  geom_bar()
```

Namun, perlu hati-hati, istilah diagram batang sebenarnya bisa mengacu
pada dua jenis plot berbeda, yang sering membuat pemula bingung. 1.
***Diagram batang untuk data mentah (belum diringkas).*** Jenis ini
seperti contoh di atas: setiap observasi di data dihitung satu kali
untuk menentukan tinggi batang. Jadi, fungsi `geom_bar()` secara
otomatis akan menghitung jumlah kemunculan tiap kategori. 2. ***Diagram
batang untuk data yang sudah diringkas.*** Dalam kasus lain, Anda
mungkin sudah memiliki data dalam bentuk hasil perhitungan atau
rata-rata, bukan data mentah. Misalnya:

```{r}
drugs <- data.frame(
  drug = c("a", "b", "c"),
  effect = c(4.2, 9.7, 6.1)
)
```

Untuk menampilkan data seperti ini, Anda perlu memberi tahu ggplot2 agar
***tidak menghitung ulang*** nilai-nilai tersebut. Caranya adalah dengan
menambahkan argumen `stat = "identity"` ke dalam `geom_bar()` agar
tinggi batang menggunakan nilai yang sudah ada. Namun, dalam banyak
kasus, plot titik (geom_point()) sering dianggap lebih efisien untuk
data yang sudah diringkas, karena: - Titik membutuhkan ruang visual
lebih sedikit dibanding batang. - Sumbu Y tidak harus selalu dimulai
dari nol.

```{r}
ggplot(drugs, aes(drug, effect)) + geom_bar(stat = "identity")
ggplot(drugs, aes(drug, effect)) + geom_point()
```

### 1.6.5 Deret Waktu Dengan PLot Garis dan Jalur

***Plot garis (line plot)*** dan ***plot jalur (path plot)*** biasanya
digunakan untuk menampilkan perubahan data dari waktu ke waktu.Keduanya
memang mirip, tetapi ada perbedaan penting: - ***Plot garis
(`geom_line()`)*** menghubungkan titik-titik data dari kiri ke kanan
berdasarkan sumbu x. - ***Plot jalur (`geom_path()`)*** menghubungkan
titik-titik berdasarkan urutan kemunculannya dalam data, bukan
berdasarkan nilai x.

Biasanya, plot garis digunakan jika sumbu x berisi waktu (misalnya tahun
atau tanggal), untuk menunjukkan bagaimana suatu nilai berubah seiring
waktu. Sedangkan plot jalur lebih cocok digunakan jika kita ingin
melihat hubungan antara dua variabel yang sama-sama berubah dari waktu
ke waktu, dengan urutan waktu diwakili oleh arah garis.

Dalam dataset `mpg`, variabel `year` hanya memiliki dua nilai, jadi
sebagai gantinya kita akan menggunakan dataset `economics` bawaan dari
ggplot2. Dataset ini berisi ***data ekonomi Amerika Serikat selama lebih
dari 40 tahun***.

Contoh pertama menampilkan dua plot garis menggunakan `geom_line()`: -
Plot pertama memperlihatkan tingkat pengangguran terhadap waktu. - Plot
kedua menunjukkan median lama waktu seseorang menganggur terhadap waktu.

```{r}
ggplot(economics, aes(date, unemploy / pop)) +
  geom_line()
ggplot(economics, aes(date, uempmed)) +
  geom_line()
```

Dari kedua grafik ini, kita bisa melihat bahwa meskipun persentase
pengangguran sempat menurun di puncak terakhir, ***rata-rata durasi
pengangguran justru meningkat***, artinya mereka yang menganggur
cenderung lebih lama mencari pekerjaan dibanding sebelumnya.

Untuk memahami hubungan antara tingkat pengangguran dan lama waktu
menganggur secara bersamaan, kita bisa menampilkannya dalam satu
grafik.Namun, jika kita membuat ***diagram sebar (scatter plot)*** saja,
kita kehilangan informasi tentang urutan waktunya. Solusinya adalah
menggunakan `geom_path()`, yang menghubungkan titik-titik sesuai urutan
waktu.

```{r}
ggplot(economics, aes(unemploy / pop, uempmed)) + 
  geom_path() +
  geom_point()

year <- function(x) as.POSIXlt(x)$year + 1900
ggplot(economics, aes(unemploy / pop, uempmed)) + 
  geom_path(colour = "grey50") +
  geom_point(aes(colour = year(date)))
```

Dengan pewarnaan ini, terlihat bahwa ***tingkat pengangguran dan lama
menganggur cenderung naik bersamaan***, namun pada tahun-tahun terakhir,
lama waktu menganggur meningkat lebih tajam dibanding tingkat
pengangguran itu sendiri.

Untuk data yang memiliki ***banyak individu (misalnya beberapa negara,
perusahaan, atau orang)*** dan setiap individu memiliki data waktu
masing-masing, kita dapat menampilkan semuanya dalam satu grafik.
Caranya, tambahkan argumen `group` di dalam `aes()` untuk mengelompokkan
data berdasarkan identitas masing-masing individu — sehingga setiap
kelompok data akan memiliki garisnya sendiri.

## 1.7 Memodifikasi Sumbu

Di bagian ini, Anda akan belajar cara melakukan ***modifikasi dasar pada
sumbu plot***, seperti mengubah nama label sumbu dan mengatur batas
tampilan data pada grafik.Meskipun nanti akan ada banyak opsi lanjutan
yang bisa digunakan, dua fungsi berikut sudah cukup membantu untuk
melakukan penyesuaian sederhana yang paling umum: - Mengubah Label Sumbu
Gunakan fungsi xlab() dan ylab() untuk memberi label yang lebih
deskriptif pada sumbu x dan y.

```{r}
ggplot(mpg, aes(cty, hwy)) +
  geom_point(alpha = 1 / 3)

```

Kode di atas hanya menampilkan plot dasar tanpa label sumbu yang jelas.
Kita bisa menambahkan label yang lebih informatif dengan:

```{r}
ggplot(mpg, aes(cty, hwy)) +
  geom_point(alpha = 1 / 3) + 
  xlab("city driving (mpg)") + 
  ylab("highway driving (mpg)")
```

Jika Anda ingin menghapus label sumbu sepenuhnya, cukup berikan nilai
NULL pada fungsinya:

```{r}
# Remove the axis labels with NULL
ggplot(mpg, aes(cty, hwy)) +
  geom_point(alpha = 1 / 3) + 
  xlab(NULL) + 
  ylab(NULL)
```

-   Mengatur Batas Sumbu Selain label, Anda juga dapat membatasi rentang
    nilai yang ditampilkan di grafik menggunakan fungsi `xlim()` dan
    `ylim()`.

```{r}
ggplot(mpg, aes(drv, hwy)) +
  geom_jitter(width = 0.25)

ggplot(mpg, aes(drv, hwy)) +
  geom_jitter(width = 0.25) + 
  xlim("f", "r") + 
  ylim(20, 30)
#> Warning: Removed 138 rows containing missing values or values outside the scale range
#> (`geom_point()`).
  
# For continuous scales, use NA to set only one limit
ggplot(mpg, aes(drv, hwy)) +
  geom_jitter(width = 0.25, na.rm = TRUE) + 
  ylim(NA, 30)
```

Menetapkan batas sumbu memang membuat tampilan lebih fokus, tetapi perlu
hati-hati: Jika grafik Anda menghitung statistik ringkasan (seperti
rata-rata), maka data di luar batas akan diubah menjadi `NA` sebelum
perhitungan dilakukan. Hal ini bisa menyebabkan hasil yang keliru, jadi
gunakan fitur ini dengan bijak.

## 1.8 Keluaran

Biasanya, kita langsung menampilkan hasil plot setelah membuatnya.
Namun, plot juga dapat disimpan terlebih dahulu ke dalam sebuah variabel
untuk kemudian dimodifikasi lebih lanjut.

```{r}
p <- ggplot(mpg, aes(displ, hwy, colour = factor(cyl))) +
  geom_point()
```

Setelah objek plot tersimpan, ada beberapa hal yang dapat dilakukan: -
***Menampilkan plot ke layar*** menggunakan fungsi print(). Dalam mode
interaktif, perintah ini dijalankan secara otomatis, tetapi jika berada
di dalam *loop* atau fungsi, kita perlu memanggil print() secara
eksplisit.

```{r}
print(p)
```

-   Simpan ke disk dengan menggunakan `ggsave()`

```{r}
# Save png to disk
ggsave("plot.png", p, width = 5, height = 5)
```

-   Melihat struktur ringkas dari plot menggunakan `summary()`. Fungsi
    ini memberikan informasi tentang data, pemetaan (*mapping*), serta
    komponen geometrik (*geom*) dan statistik yang digunakan.

```{r}
summary(p)
#> data: manufacturer, model, displ, year, cyl, trans, drv, cty, hwy, fl,
#>   class [234x11]
#> mapping:  x = ~displ, y = ~hwy, colour = ~factor(cyl)
#> faceting:  <empty> 
#> -----------------------------------
#> geom_point: na.rm = FALSE
#> stat_identity: na.rm = FALSE
#> position_identity
```

SELESAI.
